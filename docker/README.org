* Whyis and Docker

** Running the container
   Each run of the container should be considered a fresh slate for your Whyis application to be run on. In other words, /most/ changes done to the container will be erased after each run. 

   To create a new container instance using the image that was just created, run the following command below:
   #+begin_src sh
   $ docker run -p 5000:5000 -p 8080:80 -it tetherlessworld/whyis:master
   #+end_src
   While Docker images are meant to be fresh slates on each run, Docker *does* save each container instance. To prevent this behavior, add the ~--rm~ option to the command.

** Running your Whyis Application
   To bring your Whyis application into the container, you can make use of linked volumes, which essentially binds a directory on the host computer to a directory on the Docker instance. 
   
   You can make use of these by adding ~-v $PWD/application_dir:/apps/application_name~ to the run command.

*** Automation
    You can also make use of linked volumes to automatically provision the container for your application by creating another directory to hold scripts to run on container startup. To run these when the container starts up, add ~--entrypoint /path/in/container~ as an argument to the run command.

** Known Issues
   - Jetty9 issues an error message about failing to start when building the image/when starting the service 
   This is mostly due what was mentioned in the section above and overall not a major issue. 

   The issue (I think) is caused by Puppet trying to ensure that the service is running on startup, which creates the ~.pid~ file, but the container hasn't actually set up the service yet (because there is no ~systemd~ running on the container). When running the start command, the system will notice the discrepancy, but start up the service properly regardless.

   This will likely continue to show up unless the services are split up into different containers.

** Development

   There are currently two Docker images (Dockerfiles) in docker/image:

   1. whyis-deps, which contains the environment and dependencies for whyis
   2. whyis, which is the user-facing image and contains the custom code for whyis; it depends (FROM) on whyis-deps

   We assume that whyis-deps changes infrequently, whereas whyis changes frequently.
   The Continuous Integration server only builds and pushes whyis, retrieving whyis-deps from Dockerhub in the process.
   When whyis-deps changes, you will need to push it to Dockerhub manually.

   You can use docker/compose/dev to build images, as in

   #+begin_src sh
   $ cd docker/compose/dev
   $ docker-compose build whyis-deps
   #+end_src
